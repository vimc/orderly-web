package org.vaccineimpact.orderlyweb.tests.integration_tests.helpers

import org.slf4j.LoggerFactory
import org.vaccineimpact.orderlyweb.db.AppConfig
import org.vaccineimpact.orderlyweb.db.Config
import org.vaccineimpact.orderlyweb.security.KeyHelper
import org.vaccineimpact.orderlyweb.security.InternalUser
import org.vaccineimpact.orderlyweb.security.WebTokenHelper
import java.security.interfaces.RSAPublicKey
import java.security.spec.X509EncodedKeySpec
import java.time.Duration
import java.time.Instant
import java.util.*

class TestTokenGenerator(config: Config = AppConfig())
{
    private val keyPair = KeyHelper.generateKeyPair()
    private val helper = WebTokenHelper(keyPair, config["token.issuer"])
    private val logger = LoggerFactory.getLogger(TestTokenGenerator::class.java)

    init
    {
        savePublicKey()
    }

    fun generateToken(user: InternalUser): String
    {
        return helper.issuer.generator.generate(claims(user))
    }

    fun claims(user: InternalUser): Map<String, Any>
    {
        return mapOf(
                "iss" to helper.issuerName,
                "sub" to user.username,
                "exp" to Date.from(Instant.now().plus(Duration.ofMinutes(1))),
                "permissions" to user.permissions,
                "roles" to user.roles
        )
    }

    private fun savePublicKey()
    {
        // This takes the public key from our test key pair and puts it
        // where the Reports API will read it in. This means that tokens
        // generated by this TestTokenGenerator will be acceptable to the
        // API.
        val publicKey = keyPair.public as RSAPublicKey
        val spec = X509EncodedKeySpec(publicKey.encoded)
        logger.info("API should use this public key for auth token verification: "
                + Base64.getEncoder().encodeToString(publicKey.encoded))
        KeyHelper.keyFile.createNewFile()
        KeyHelper.keyFile.writeBytes(spec.encoded)
    }
}